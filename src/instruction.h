#ifndef INSTRUCTION_H
#define INSTRUCTION_H

#define INSTRUCTION_FORMAT_DATA_PROCESSING                              (0)
#define INSTRUCTION_FORMAT_MULTIPLY                                     (0b0000000000000000000010010000)
#define INSTRUCTION_FORMAT_MULTIPLY_LONG                                (0b0000100000000000000010010000)
#define INSTRUCTION_FORMAT_SINGLE_DATA_SWAP                             (0b0001000000000000000010010000)
#define INSTRUCTION_FORMAT_BRANCH_AND_EXCHANGE                          (0b0001001011111111111100010000)
#define INSTRUCTION_FORMAT_HALFWORD_DATA_TRANSFER_REGISTER_OFFSET       (0b10010000)
#define INSTRUCTION_FORMAT_HALFWORD_DATA_TRANSFER_IMMEDIATE_OFFSET      (0b0000010000000000000010010000)
#define INSTRUCTION_FORMAT_SINGLE_DATA_TRANSFER                         (1 << 26)
#define INSTRUCTION_FORMAT_UNDEFINED                                    ((0b11 << 25) | (1 << 4))
#define INSTRUCTION_FORMAT_BLOCK_DATA_TRANSFER                          (1 << 27)
#define INSTRUCTION_FORMAT_BRANCH                                       (0b101 << 25)
#define INSTRUCTION_FORMAT_COPROCESSOR_DATA_TRANSFER                    (0b11 << 26)
#define INSTRUCTION_FORMAT_COPROCESSOR_DATA_OPERATION                   (0b111 << 25)
#define INSTRUCTION_FORMAT_COPROCESSOR_REGISTER_TRANSFER                ((0b111 << 25) | (1 << 4))
#define INSTRUCTION_FORMAT_SOFTWARE_INTERRUPT                           (0b1111 << 24)


//
// Thumb Instructions
//
#define THUMB_INSTRUCTION_FORMAT_MOVE_SHIFTED_REGISTER                  (0)
#define THUMB_INSTRUCTION_FORMAT_ADD_SUBTRACT                           (0b11 << 11)
#define THUMB_INSTRUCTION_FORMAT_MOVE_COMPARE_ADD_SUBTRACT_IMMEDIATE    (1 << 13)
#define THUMB_INSTRUCTION_FORMAT_ALU_OPERATIONS                         (1 << 14)
#define THUMB_INSTRUCTION_FORMAT_HI_REGISTER_OPERATIONS_BRANCH_EXCHANGE (0b10001 << 10)
#define THUMB_INSTRUCTION_FORMAT_PC_RELATIVE_LOAD                       (0b1001 << 11)
#define THUMB_INSTRUCTION_FORMAT_LOAD_STORE_WITH_REGISTER_OFFSET        (0b101000 << 9)
#define THUMB_INSTRUCTION_FORMAT_LOAD_STORE_SIGN_EXTENDED_BYTE_HALFWORD (0b101001 << 9)
#define THUMB_INSTRUCTION_FORMAT_LOAD_STORE_WITH_IMMEDIATE_OFFSET       (0b11 << 13)
#define THUMB_INSTRUCTION_FORMAT_LOAD_STORE_HALFWORD                    (1 << 15)
#define THUMB_INSTRUCTION_FORMAT_SP_RELATIVE_LOAD_STORE                 (0b1001 << 12)
#define THUMB_INSTRUCTION_FORMAT_LOAD_ADDRESS                           (0b101 << 13)
#define THUMB_INSTRUCTION_FORMAT_ADD_OFFSET_STACK_POINTER               (0b1011 << 12)
#define THUMB_INSTRUCTION_FORMAT_PUSH_POP_REGISTERS                     (0b101101 << 10)
#define THUMB_INSTRUCTION_FORMAT_MULTIPLE_LOAD_STORE                    (0b11 << 14)
#define THUMB_INSTRUCTION_FORMAT_CONDITIONAL_BRANCH                     (0b1101 << 12)
#define THUMB_INSTRUCTION_FORMAT_SOFTWARE_INTERRUPT                     (0b11011111 << 8)
#define THUMB_INSTRUCTION_FORMAT_UNCONDITIONAL_BRANCH                   (0b111 << 13)
#define THUMB_INSTRUCTION_FORMAT_LONG_BRANCH_WITH_LINK                  (0b1111 << 12)



typedef enum ShiftType {
    SHIFT_TYPE_LOGICAL_LEFT     = 0b00,
    SHIFT_TYPE_LOGICAL_RIGHT    = 0b01,
    SHIFT_TYPE_ARITHMETIC_RIGHT = 0b10,
    SHIFT_TYPE_ROTATE_RIGHT     = 0b11,
} ShiftType;

typedef enum ThumbShiftType {
    THUMB_SHIFT_TYPE_LOGICAL_LEFT       = 0,
    THUMB_SHIFT_TYPE_LOGICAL_RIGHT      = 1,
    THUMB_SHIFT_TYPE_ARITHMETIC_RIGHT   = 2,
} ThumbShiftType;

typedef enum Condition {
    CONDITION_EQ = 0b0000,
    CONDITION_NE = 0b0001,
    CONDITION_CS = 0b0010,
    CONDITION_CC = 0b0011,
    CONDITION_MI = 0b0100,
    CONDITION_PL = 0b0101,
    CONDITION_VS = 0b0110,
    CONDITION_VC = 0b0111,
    CONDITION_HI = 0b1000,
    CONDITION_LS = 0b1001,
    CONDITION_GE = 0b1010,
    CONDITION_LT = 0b1011,
    CONDITION_GT = 0b1100,
    CONDITION_LE = 0b1101,
    CONDITION_AL = 0b1110,
} Condition;

typedef enum InstructionType {
    INSTRUCTION_NONE,

    // Branch
    INSTRUCTION_B,
    INSTRUCTION_BX,

    // Data Processing
    INSTRUCTION_AND,
    INSTRUCTION_EOR,
    INSTRUCTION_SUB,
    INSTRUCTION_RSB,
    INSTRUCTION_ADD,
    INSTRUCTION_ADC,
    INSTRUCTION_SBC,
    INSTRUCTION_RSC,
    INSTRUCTION_TST,
    INSTRUCTION_TEQ,
    INSTRUCTION_CMP,
    INSTRUCTION_CMN,
    INSTRUCTION_ORR,
    INSTRUCTION_MOV,
    INSTRUCTION_BIC,
    INSTRUCTION_MVN,

    // PSR Transfer
    INSTRUCTION_MRS,
    INSTRUCTION_MSR,

    // Multiply
    INSTRUCTION_MUL,
    INSTRUCTION_MLA,
    INSTRUCTION_MULL,
    INSTRUCTION_MLAL,

    // Single Data Transfer
    INSTRUCTION_LDR,
    INSTRUCTION_STR,

    // Halfword and signed data transfer
    
    // TODO: Used to differentiate the instructions with immediate offset against register offset. Maybe change this later.
    INSTRUCTION_LDRH_IMM,
    INSTRUCTION_STRH_IMM,
    INSTRUCTION_LDRSB_IMM,
    INSTRUCTION_LDRSH_IMM,
    
    INSTRUCTION_LDRH,
    INSTRUCTION_STRH,
    INSTRUCTION_LDRSB,
    INSTRUCTION_LDRSH,

    // Block Data Transfer
    INSTRUCTION_LDM,
    INSTRUCTION_STM,

    // Single Data Swap
    INSTRUCTION_SWP,

    // Software Interrupt
    INSTRUCTION_SWI,

    // Coprocessor Data Operations
    INSTRUCTION_CDP,

    // Coprocessor Data Transfers
    INSTRUCTION_STC,
    INSTRUCTION_LDC,

    // Coprocessor Register Transfers
    INSTRUCTION_MCR,
    INSTRUCTION_MRC,



    //
    // Thumb instructions
    //

    INSTRUCTION_MOVE_SHIFTED_REGISTER,
    INSTRUCTION_ADD_SUBTRACT,
    INSTRUCTION_MOVE_COMPARE_ADD_SUBTRACT_IMMEDIATE,
    INSTRUCTION_ALU_OPERATIONS,
    INSTRUCTION_HI_REGISTER_OPERATIONS_BRANCH_EXCHANGE,
    INSTRUCTION_PC_RELATIVE_LOAD,
    INSTRUCTION_LOAD_STORE_WITH_REGISTER_OFFSET,
    INSTRUCTION_LOAD_STORE_SIGN_EXTENDED_BYTE_HALFWORD,
    INSTRUCTION_LOAD_STORE_WITH_IMMEDIATE_OFFSET,
    INSTRUCTION_LOAD_STORE_HALFWORD,
    INSTRUCTION_SP_RELATIVE_LOAD_STORE,
    INSTRUCTION_LOAD_ADDRESS,
    INSTRUCTION_ADD_OFFSET_TO_STACK_POINTER,
    INSTRUCTION_PUSH_POP_REGISTERS,
    INSTRUCTION_MULTIPLE_LOAD_STORE,
    INSTRUCTION_CONDITIONAL_BRANCH,
    INSTRUCTION_SOFTWARE_INTERRUPT,
    INSTRUCTION_UNCONDITIONAL_BRANCH,
    INSTRUCTION_LONG_BRANCH_WITH_LINK,
} InstructionType;

char *
get_instruction_type_string(InstructionType type)
{
    switch (type) {
        case INSTRUCTION_NONE: return "INSTRUCTION_NONE";
        case INSTRUCTION_B: return "INSTRUCTION_B";
        case INSTRUCTION_BX: return "INSTRUCTION_BX";
        case INSTRUCTION_AND: return "INSTRUCTION_AND";
        case INSTRUCTION_EOR: return "INSTRUCTION_EOR";
        case INSTRUCTION_SUB: return "INSTRUCTION_SUB";
        case INSTRUCTION_RSB: return "INSTRUCTION_RSB";
        case INSTRUCTION_ADD: return "INSTRUCTION_ADD";
        case INSTRUCTION_ADC: return "INSTRUCTION_ADC";
        case INSTRUCTION_SBC: return "INSTRUCTION_SBC";
        case INSTRUCTION_RSC: return "INSTRUCTION_RSC";
        case INSTRUCTION_TST: return "INSTRUCTION_TST";
        case INSTRUCTION_TEQ: return "INSTRUCTION_TEQ";
        case INSTRUCTION_CMP: return "INSTRUCTION_CMP";
        case INSTRUCTION_CMN: return "INSTRUCTION_CMN";
        case INSTRUCTION_ORR: return "INSTRUCTION_ORR";
        case INSTRUCTION_MOV: return "INSTRUCTION_MOV";
        case INSTRUCTION_BIC: return "INSTRUCTION_BIC";
        case INSTRUCTION_MVN: return "INSTRUCTION_MVN";
        case INSTRUCTION_MRS: return "INSTRUCTION_MRS";
        case INSTRUCTION_MSR: return "INSTRUCTION_MSR";
        case INSTRUCTION_MUL: return "INSTRUCTION_MUL";
        case INSTRUCTION_MLA: return "INSTRUCTION_MLA";
        case INSTRUCTION_MULL: return "INSTRUCTION_MULL";
        case INSTRUCTION_MLAL: return "INSTRUCTION_MLAL";
        case INSTRUCTION_LDR: return "INSTRUCTION_LDR";
        case INSTRUCTION_STR: return "INSTRUCTION_STR";
        case INSTRUCTION_LDRH_IMM: return "INSTRUCTION_LDRH_IMM";
        case INSTRUCTION_STRH_IMM: return "INSTRUCTION_STRH_IMM";
        case INSTRUCTION_LDRSB_IMM: return "INSTRUCTION_LDRSB_IMM";
        case INSTRUCTION_LDRSH_IMM: return "INSTRUCTION_LDRSH_IMM";
        case INSTRUCTION_LDRH: return "INSTRUCTION_LDRH";
        case INSTRUCTION_STRH: return "INSTRUCTION_STRH";
        case INSTRUCTION_LDRSB: return "INSTRUCTION_LDRSB";
        case INSTRUCTION_LDRSH: return "INSTRUCTION_LDRSH";
        case INSTRUCTION_LDM: return "INSTRUCTION_LDM";
        case INSTRUCTION_STM: return "INSTRUCTION_STM";
        case INSTRUCTION_SWP: return "INSTRUCTION_SWP";
        case INSTRUCTION_SWI: return "INSTRUCTION_SWI";
        case INSTRUCTION_CDP: return "INSTRUCTION_CDP";
        case INSTRUCTION_STC: return "INSTRUCTION_STC";
        case INSTRUCTION_LDC: return "INSTRUCTION_LDC";
        case INSTRUCTION_MCR: return "INSTRUCTION_MCR";
        case INSTRUCTION_MRC: return "INSTRUCTION_MRC";
        case INSTRUCTION_MOVE_SHIFTED_REGISTER: return "INSTRUCTION_MOVE_SHIFTED_REGISTER";
        case INSTRUCTION_ADD_SUBTRACT: return "INSTRUCTION_ADD_SUBTRACT";
        case INSTRUCTION_MOVE_COMPARE_ADD_SUBTRACT_IMMEDIATE: return "INSTRUCTION_MOVE_COMPARE_ADD_SUBTRACT_IMMEDIATE";
        case INSTRUCTION_ALU_OPERATIONS: return "INSTRUCTION_ALU_OPERATIONS";
        case INSTRUCTION_HI_REGISTER_OPERATIONS_BRANCH_EXCHANGE: return "INSTRUCTION_HI_REGISTER_OPERATIONS_BRANCH_EXCHANGE";
        case INSTRUCTION_PC_RELATIVE_LOAD: return "INSTRUCTION_PC_RELATIVE_LOAD";
        case INSTRUCTION_LOAD_STORE_WITH_REGISTER_OFFSET: return "INSTRUCTION_LOAD_STORE_WITH_REGISTER_OFFSET";
        case INSTRUCTION_LOAD_STORE_SIGN_EXTENDED_BYTE_HALFWORD: return "INSTRUCTION_LOAD_STORE_SIGN_EXTENDED_BYTE_HALFWORD";
        case INSTRUCTION_LOAD_STORE_WITH_IMMEDIATE_OFFSET: return "INSTRUCTION_LOAD_STORE_WITH_IMMEDIATE_OFFSET";
        case INSTRUCTION_LOAD_STORE_HALFWORD: return "INSTRUCTION_LOAD_STORE_HALFWORD";
        case INSTRUCTION_SP_RELATIVE_LOAD_STORE: return "INSTRUCTION_SP_RELATIVE_LOAD_STORE";
        case INSTRUCTION_LOAD_ADDRESS: return "INSTRUCTION_LOAD_ADDRESS";
        case INSTRUCTION_ADD_OFFSET_TO_STACK_POINTER: return "INSTRUCTION_ADD_OFFSET_TO_STACK_POINTER";
        case INSTRUCTION_PUSH_POP_REGISTERS: return "INSTRUCTION_PUSH_POP_REGISTERS";
        case INSTRUCTION_MULTIPLE_LOAD_STORE: return "INSTRUCTION_MULTIPLE_LOAD_STORE";
        case INSTRUCTION_CONDITIONAL_BRANCH: return "INSTRUCTION_CONDITIONAL_BRANCH";
        case INSTRUCTION_SOFTWARE_INTERRUPT: return "INSTRUCTION_SOFTWARE_INTERRUPT";
        case INSTRUCTION_UNCONDITIONAL_BRANCH: return "INSTRUCTION_UNCONDITIONAL_BRANCH";
        case INSTRUCTION_LONG_BRANCH_WITH_LINK: return "INSTRUCTION_LONG_BRANCH_WITH_LINK";
    }

    return "UNKNOWN";
}

typedef enum DataProcessingTypes {
    DATA_PROCESSING_LOGICAL,
    DATA_PROCESSING_ARITHMETIC,
} DataProcessingTypes;

InstructionType data_processing_types[] = {
    [INSTRUCTION_AND] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_EOR] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_SUB] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_RSB] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_ADD] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_ADC] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_SBC] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_RSC] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_TST] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_TEQ] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_CMP] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_CMN] = DATA_PROCESSING_ARITHMETIC,
    [INSTRUCTION_ORR] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_MOV] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_BIC] = DATA_PROCESSING_LOGICAL,
    [INSTRUCTION_MVN] = DATA_PROCESSING_LOGICAL,
};

typedef enum InstructionCategory {
    INSTRUCTION_CATEGORY_BRANCH,
    INSTRUCTION_CATEGORY_DATA_PROCESSING,
    INSTRUCTION_CATEGORY_PSR_TRANSFER,
    INSTRUCTION_CATEGORY_MULTIPLY,
    INSTRUCTION_CATEGORY_SINGLE_DATA_TRANSFER,
    INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    INSTRUCTION_CATEGORY_BLOCK_DATA_TRANSFER,
    INSTRUCTION_CATEGORY_SINGLE_DATA_SWAP,
    INSTRUCTION_CATEGORY_SOFTWARE_INTERRUPT,
    INSTRUCTION_CATEGORY_COPROCESSOR_DATA_OPERATIONS,
    INSTRUCTION_CATEGORY_COPROCESSOR_DATA_TRANSFERS,
    INSTRUCTION_CATEGORY_COPROCESSOR_REGISTER_TRANSFERS,

    INSTRUCTION_CATEGORY_DEBUG,
} InstructionCategory;

InstructionCategory instruction_categories[] = {
    [INSTRUCTION_B] = INSTRUCTION_CATEGORY_BRANCH,
    [INSTRUCTION_BX] = INSTRUCTION_CATEGORY_BRANCH,

    [INSTRUCTION_AND] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_EOR] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_SUB] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_RSB] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_ADD] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_ADC] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_SBC] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_RSC] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_TST] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_TEQ] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_CMP] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_CMN] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_ORR] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_MOV] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_BIC] = INSTRUCTION_CATEGORY_DATA_PROCESSING,
    [INSTRUCTION_MVN] = INSTRUCTION_CATEGORY_DATA_PROCESSING,

    [INSTRUCTION_MRS] = INSTRUCTION_CATEGORY_PSR_TRANSFER,
    [INSTRUCTION_MSR] = INSTRUCTION_CATEGORY_PSR_TRANSFER,

    [INSTRUCTION_MUL] = INSTRUCTION_CATEGORY_MULTIPLY,
    [INSTRUCTION_MLA] = INSTRUCTION_CATEGORY_MULTIPLY,
    [INSTRUCTION_MULL] = INSTRUCTION_CATEGORY_MULTIPLY,
    [INSTRUCTION_MLAL] = INSTRUCTION_CATEGORY_MULTIPLY,

    [INSTRUCTION_LDR] = INSTRUCTION_CATEGORY_SINGLE_DATA_TRANSFER,
    [INSTRUCTION_STR] = INSTRUCTION_CATEGORY_SINGLE_DATA_TRANSFER,

    [INSTRUCTION_LDRH_IMM] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_STRH_IMM] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_LDRSB_IMM] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_LDRSH_IMM] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_LDRH] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_STRH] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_LDRSB] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,
    [INSTRUCTION_LDRSH] = INSTRUCTION_CATEGORY_HALFWORD_AND_SIGNED_DATA_TRANSFER,

    [INSTRUCTION_LDM] = INSTRUCTION_CATEGORY_BLOCK_DATA_TRANSFER,
    [INSTRUCTION_STM] = INSTRUCTION_CATEGORY_BLOCK_DATA_TRANSFER,

    [INSTRUCTION_SWP] = INSTRUCTION_CATEGORY_SINGLE_DATA_SWAP,

    [INSTRUCTION_SWI] = INSTRUCTION_CATEGORY_SOFTWARE_INTERRUPT,

    [INSTRUCTION_CDP] = INSTRUCTION_CATEGORY_COPROCESSOR_DATA_OPERATIONS,

    [INSTRUCTION_STC] = INSTRUCTION_CATEGORY_COPROCESSOR_DATA_TRANSFERS,
    [INSTRUCTION_LDC] = INSTRUCTION_CATEGORY_COPROCESSOR_DATA_TRANSFERS,

    [INSTRUCTION_MCR] = INSTRUCTION_CATEGORY_COPROCESSOR_REGISTER_TRANSFERS,
    [INSTRUCTION_MRC] = INSTRUCTION_CATEGORY_COPROCESSOR_REGISTER_TRANSFERS,
};

typedef struct Instruction {
    InstructionType type;
    Condition condition;
    int offset;
    u8 L;
    u8 S;
    union {
        u8 rn;
        u8 rb;
    };
    u8 I;
    u8 P;
    u8 U;
    u8 W;
    u8 B;
    u8 A;
    u8 H;
    union {
        u16 second_operand;
        u16 register_list;
    };
    u8 rd;
    u8 rm;
    u8 rs;
    u8 rdhi;
    u8 rdlo;
    u16 source_operand;
    u8 value_8;
    u8 R;
    u8 H1;
    u8 H2;
    u8 op;
    u32 mask;

    u32 address;
    u32 encoding;
} Instruction;


void fetch();
void decode();
void execute();

void thumb_fetch();
void thumb_decode();
void thumb_execute();



static u32
rotate_right(u32 value, u32 shift, u8 bits)
{
    if (shift == 0) return value;

    u32 value_to_rotate = value & ((1 << shift) - 1);
    u32 rotate_masked = value_to_rotate << (bits - shift);

    return (value >> shift) | rotate_masked;
}

static u32
arithmetic_shift_right(u32 value, u8 shift)
{
    u8 msb = (value >> 31) & 1;
    u32 msb_replicated = (-msb << (32 - shift));

    return (value >> shift) | msb_replicated;
}

// TODO: get rid of this because depending on the instruction and shift type the value and carry are set differently.
static u32
apply_shift(u32 value, u32 shift, ShiftType shift_type, u8 *carry)
{
    switch (shift_type) {
        case SHIFT_TYPE_LOGICAL_LEFT: {
            *carry = (value >> (32 - shift)) & 1;

            return value << shift;
        } break;
        case SHIFT_TYPE_LOGICAL_RIGHT: {
            *carry = (value >> (shift - 1) & 1);
            
            return value >> shift;
        } break;
        case SHIFT_TYPE_ARITHMETIC_RIGHT: {
            *carry = (value >> (shift - 1) & 1);
            
            
        } break;
        case SHIFT_TYPE_ROTATE_RIGHT: {
            u32 result = rotate_right(value, shift, 32);
            
            *carry = (result >> 31) & 1;
            
            return result;
        } break;
    }

    return value;
}

/**
 * actual_bits_value: how many bits are used in value.
 */
static u32
left_shift_sign_extended(u32 value, u8 actual_bits_value, u8 shift)
{
    u8 sign = (value >> (actual_bits_value - 1)) & 1;
    u32 value_sign_extended = (-sign << (actual_bits_value)) | value;

    return (value_sign_extended << shift);
}

static u32
sign_extend(u32 value, u8 actual_bits_value)
{
    u8 sign = (value >> (actual_bits_value - 1)) & 1;
    u32 value_sign_extended = (-sign << (actual_bits_value)) | value;

    return value_sign_extended;
}

u8 number_set_bits(u32 n)
{
    u8 result = 0;
    while (n > 0) {
        if (n & 1) result++;
        n >>= 1;
    }

    return result;
}

#endif // INSTRUCTION_H